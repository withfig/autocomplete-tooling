{
  "interfaces": [
    {
      "name": "BaseSuggestion",
      "hasDocComment": true,
      "extends": [],
      "members": [
        {
          "name": "displayName",
          "excluded": false,
          "summary": "The string that is displayed in the UI for a given suggestion.",
          "parameters": [],
          "optional": true,
          "declaration": "displayName?: string",
          "examples": [
            "The npm CLI has a subcommand called `install`. If we wanted\nto display some custom text like `Install an NPM package ðŸ“¦` we would set\n`name: \"install\"` and `displayName: \"Install an NPM package ðŸ“¦\"`"
          ],
          "default": "the name prop",
          "hasDocComment": true
        },
        {
          "name": "insertValue",
          "excluded": false,
          "summary": "The value that's inserted into the terminal when a user presses enter/tab or clicks on a menu item.",
          "discussion": "You can use `\\n` to insert a newline or `\\b` to insert a backspace.\nYou can also optionally specify {cursor} in the string and Fig will automatically place the cursor there after insert.",
          "parameters": [],
          "optional": true,
          "declaration": "insertValue?: string",
          "examples": [
            "For the `git commit` subcommand, the `-m` option has an insert value of `-m '{cursor}'`"
          ],
          "default": "The value of the name prop.",
          "hasDocComment": true
        },
        {
          "name": "replaceValue",
          "excluded": false,
          "summary": "When the suggestion is inserted, replace the command with this string",
          "discussion": "You can use `\\n` to insert a newline or `\\b` to insert a backspace.\nYou can also optionally specify {cursor} in the string and Fig will automatically place the cursor there after insert.\nNote that currently the entire edit buffer will be replaced. Eventually, only the root command will be replaced, preserving pipes and continuations.",
          "parameters": [],
          "optional": true,
          "declaration": "replaceValue?: string",
          "examples": [],
          "hasDocComment": true
        },
        {
          "name": "description",
          "excluded": false,
          "summary": "The text that gets rendered at the bottom of the autocomplete box (or the side if you hit âŒ˜i)",
          "parameters": [],
          "optional": true,
          "declaration": "description?: string",
          "examples": ["\"Your commit message\""],
          "hasDocComment": true
        },
        {
          "name": "icon",
          "excluded": false,
          "summary": "The icon that is rendered is based on the type.",
          "discussion": "Icons can be a 1 character string, a URL, or Fig's [icon protocol](https://fig.io/docs/reference/suggestion/icon-api) (fig://) which lets you generate\ncolorful and fun systems icons.",
          "parameters": [],
          "optional": true,
          "declaration": "icon?: string",
          "examples": [
            "`A`",
            "`ðŸ˜Š`",
            "`https://www.herokucdn.com/favicon.ico`",
            "`fig://icon?type=file`"
          ],
          "default": "related to the type of the object (e.g. `Suggestion`, `Subcommand`, `Option`, `Arg`)",
          "hasDocComment": true
        },
        {
          "name": "isDangerous",
          "excluded": false,
          "summary": "Specifies whether the suggestion is \"dangerous\".",
          "discussion": "If true, Fig will not enable its autoexecute functionality. Autoexecute means if a user selects a suggestion it will insert the text and run the command. We signal this by changing the icon to red.\nSetting `isDangerous` to `true` will make it harder for a user to accidentally run a dangerous command.",
          "parameters": [],
          "optional": true,
          "declaration": "isDangerous?: boolean",
          "examples": [
            "This is used in the `rm` spec. Why? Because we don't want users to accidentally delete their files so we make it just a little bit harder..."
          ],
          "default": "false",
          "hasDocComment": true
        },
        {
          "name": "priority",
          "excluded": false,
          "summary": "The number used to rank suggestions in autocomplete. Number must be from 0-100. Higher priorities rank higher.",
          "discussion": "Fig ranks suggestions by recency. To do this, we check if a suggestion has been selected before. If yes and the suggestions has:\n- a priority between 50-75, the priority will be replaced with 75, then we will add the timestamp of when that suggestion was selected as a decimal.\n- a priority outside of 50-75, the priority will be increased by the timestamp of when that suggestion was selected as a decimal.\nIf it has not been selected before, Fig will keep the same priority as was set in the completion spec\nIf it was not set in the spec, it will default to 50.",
          "parameters": [],
          "optional": true,
          "declaration": "priority?: number",
          "examples": [
            "Let's say a user has previously selected a suggestion at unix timestamp 1634087677:\n    - If completion spec did not set a priority (Fig treats this as priority 50), its priority would change to 75 + 0.1634087677 = 75.1634087677;\n    - If completion spec set a priority of 49 or less, its priority would change to 49 + 0.1634087677 = 49.1634087677;\n    - If completion spec set a priority of 76 or more, its priority would change to 76 + 0.1634087677 = 76.1634087677;\n    - If a user had never selected a suggestion, then its priority would just stay as is (or if not set, default to 50).",
            "If you want your suggestions to always be:\n    - at the top order, rank them 76 or above.\n    - at the bottom, rank them 49 or below"
          ],
          "default": "50",
          "hasDocComment": true
        },
        {
          "name": "hidden",
          "excluded": false,
          "summary": "Specifies whether a suggestion should be hidden from results.",
          "discussion": "Fig will only show it if the user exactly types the name.",
          "parameters": [],
          "optional": true,
          "declaration": "hidden?: boolean",
          "examples": [
            "The \"-\" suggestion is hidden in the `cd` spec. You will only see it if you type exactly  `cd -`"
          ],
          "default": "false",
          "hasDocComment": true
        },
        {
          "name": "deprecated",
          "excluded": false,
          "summary": "Specifies whether a suggestion is deprecated.",
          "discussion": "It is possible to specify a suggestion to replace the deprecated one.\n- The `description` of the deprecated object (e.g `deprecated: { description: 'The --no-ansi option has been deprecated in v2' }`) is used to provide infos about the deprecation.\n- `deprecated: true` and `deprecated: { }` behave the same and will just display the suggestion as deprecated.",
          "parameters": [],
          "optional": true,
          "declaration": "deprecated?: boolean | Omit<BaseSuggestion, \"deprecated\">",
          "examples": [
            "```js\ndeprecated: { insertValue: '--ansi never', description: 'The --no-ansi option has been deprecated in v2' }\n```"
          ],
          "hasDocComment": true
        }
      ],
      "inheritedMembers": []
    },
    {
      "name": "Suggestion",
      "hasDocComment": true,
      "extends": ["BaseSuggestion"],
      "members": [
        {
          "name": "name",
          "excluded": false,
          "summary": "The string Fig uses when filtering over a list of suggestions to check for a match.",
          "discussion": "When a a user is typing in the terminal, the query term (the token they are currently typing) filters over all suggestions in a list by checking if the queryTerm matches the prefix of the name.\nThe `displayName` prop also defaults to the value of name.\n\nThe `name` props of suggestion, subcommand, option, and arg objects are all different. It's important to read them all carefully.",
          "parameters": [],
          "optional": true,
          "declaration": "name?: string | string[]",
          "examples": [
            "If a user types git `c`, any Suggestion objects with a name prop that has a value starting with \"c\" will match."
          ],
          "hasDocComment": true
        },
        {
          "name": "type",
          "excluded": false,
          "summary": "The type of a suggestion object.",
          "discussion": "The type determines\n- the default icon Fig uses (e.g. a file or folder searches for the system icon, a subcommand has a specific icon etc)\n- whether we allow users to auto-execute a command",
          "parameters": [],
          "optional": true,
          "declaration": "type?:\n  | \"folder\"\n  | \"file\"\n  | \"arg\"\n  | \"subcommand\"\n  | \"option\"\n  | \"special\"\n  | \"mixin\"\n  | \"shortcut\"",
          "examples": [],
          "hasDocComment": true
        }
      ],
      "inheritedMembers": [
        {
          "name": "displayName",
          "excluded": false,
          "summary": "The string that is displayed in the UI for a given suggestion.",
          "parameters": [],
          "optional": true,
          "declaration": "displayName?: string",
          "examples": [
            "The npm CLI has a subcommand called `install`. If we wanted\nto display some custom text like `Install an NPM package ðŸ“¦` we would set\n`name: \"install\"` and `displayName: \"Install an NPM package ðŸ“¦\"`"
          ],
          "default": "the name prop",
          "hasDocComment": true
        },
        {
          "name": "insertValue",
          "excluded": false,
          "summary": "The value that's inserted into the terminal when a user presses enter/tab or clicks on a menu item.",
          "discussion": "You can use `\\n` to insert a newline or `\\b` to insert a backspace.\nYou can also optionally specify {cursor} in the string and Fig will automatically place the cursor there after insert.",
          "parameters": [],
          "optional": true,
          "declaration": "insertValue?: string",
          "examples": [
            "For the `git commit` subcommand, the `-m` option has an insert value of `-m '{cursor}'`"
          ],
          "default": "The value of the name prop.",
          "hasDocComment": true
        },
        {
          "name": "replaceValue",
          "excluded": false,
          "summary": "When the suggestion is inserted, replace the command with this string",
          "discussion": "You can use `\\n` to insert a newline or `\\b` to insert a backspace.\nYou can also optionally specify {cursor} in the string and Fig will automatically place the cursor there after insert.\nNote that currently the entire edit buffer will be replaced. Eventually, only the root command will be replaced, preserving pipes and continuations.",
          "parameters": [],
          "optional": true,
          "declaration": "replaceValue?: string",
          "examples": [],
          "hasDocComment": true
        },
        {
          "name": "description",
          "excluded": false,
          "summary": "The text that gets rendered at the bottom of the autocomplete box (or the side if you hit âŒ˜i)",
          "parameters": [],
          "optional": true,
          "declaration": "description?: string",
          "examples": ["\"Your commit message\""],
          "hasDocComment": true
        },
        {
          "name": "icon",
          "excluded": false,
          "summary": "The icon that is rendered is based on the type.",
          "discussion": "Icons can be a 1 character string, a URL, or Fig's [icon protocol](https://fig.io/docs/reference/suggestion/icon-api) (fig://) which lets you generate\ncolorful and fun systems icons.",
          "parameters": [],
          "optional": true,
          "declaration": "icon?: string",
          "examples": [
            "`A`",
            "`ðŸ˜Š`",
            "`https://www.herokucdn.com/favicon.ico`",
            "`fig://icon?type=file`"
          ],
          "default": "related to the type of the object (e.g. `Suggestion`, `Subcommand`, `Option`, `Arg`)",
          "hasDocComment": true
        },
        {
          "name": "isDangerous",
          "excluded": false,
          "summary": "Specifies whether the suggestion is \"dangerous\".",
          "discussion": "If true, Fig will not enable its autoexecute functionality. Autoexecute means if a user selects a suggestion it will insert the text and run the command. We signal this by changing the icon to red.\nSetting `isDangerous` to `true` will make it harder for a user to accidentally run a dangerous command.",
          "parameters": [],
          "optional": true,
          "declaration": "isDangerous?: boolean",
          "examples": [
            "This is used in the `rm` spec. Why? Because we don't want users to accidentally delete their files so we make it just a little bit harder..."
          ],
          "default": "false",
          "hasDocComment": true
        },
        {
          "name": "priority",
          "excluded": false,
          "summary": "The number used to rank suggestions in autocomplete. Number must be from 0-100. Higher priorities rank higher.",
          "discussion": "Fig ranks suggestions by recency. To do this, we check if a suggestion has been selected before. If yes and the suggestions has:\n- a priority between 50-75, the priority will be replaced with 75, then we will add the timestamp of when that suggestion was selected as a decimal.\n- a priority outside of 50-75, the priority will be increased by the timestamp of when that suggestion was selected as a decimal.\nIf it has not been selected before, Fig will keep the same priority as was set in the completion spec\nIf it was not set in the spec, it will default to 50.",
          "parameters": [],
          "optional": true,
          "declaration": "priority?: number",
          "examples": [
            "Let's say a user has previously selected a suggestion at unix timestamp 1634087677:\n    - If completion spec did not set a priority (Fig treats this as priority 50), its priority would change to 75 + 0.1634087677 = 75.1634087677;\n    - If completion spec set a priority of 49 or less, its priority would change to 49 + 0.1634087677 = 49.1634087677;\n    - If completion spec set a priority of 76 or more, its priority would change to 76 + 0.1634087677 = 76.1634087677;\n    - If a user had never selected a suggestion, then its priority would just stay as is (or if not set, default to 50).",
            "If you want your suggestions to always be:\n    - at the top order, rank them 76 or above.\n    - at the bottom, rank them 49 or below"
          ],
          "default": "50",
          "hasDocComment": true
        },
        {
          "name": "hidden",
          "excluded": false,
          "summary": "Specifies whether a suggestion should be hidden from results.",
          "discussion": "Fig will only show it if the user exactly types the name.",
          "parameters": [],
          "optional": true,
          "declaration": "hidden?: boolean",
          "examples": [
            "The \"-\" suggestion is hidden in the `cd` spec. You will only see it if you type exactly  `cd -`"
          ],
          "default": "false",
          "hasDocComment": true
        },
        {
          "name": "deprecated",
          "excluded": false,
          "summary": "Specifies whether a suggestion is deprecated.",
          "discussion": "It is possible to specify a suggestion to replace the deprecated one.\n- The `description` of the deprecated object (e.g `deprecated: { description: 'The --no-ansi option has been deprecated in v2' }`) is used to provide infos about the deprecation.\n- `deprecated: true` and `deprecated: { }` behave the same and will just display the suggestion as deprecated.",
          "parameters": [],
          "optional": true,
          "declaration": "deprecated?: boolean | Omit<BaseSuggestion, \"deprecated\">",
          "examples": [
            "```js\ndeprecated: { insertValue: '--ansi never', description: 'The --no-ansi option has been deprecated in v2' }\n```"
          ],
          "hasDocComment": true
        }
      ]
    },
    {
      "name": "Subcommand",
      "hasDocComment": true,
      "extends": ["BaseSuggestion"],
      "members": [
        {
          "name": "name",
          "excluded": false,
          "summary": "The name of the subcommand. Should exactly match the name defined by the CLI tool.",
          "discussion": "If a subcommand has multiple aliases, they should be included as an array.\n\nNote that Fig's autocomplete engine requires this `name` to match the text typed by the user in the shell.\n\nTo customize the title that is displayed to the user, use `displayName`.",
          "parameters": [],
          "optional": false,
          "declaration": "name: string | string[]",
          "examples": [
            "For `git checkout`, the subcommand `checkout` would have `name: \"checkout\"`",
            "For `npm install`, the subcommand `install` would have `name: [\"install\", \"i\"]` as these two values both represent the same subcommand."
          ],
          "hasDocComment": true
        },
        {
          "name": "subcommands",
          "excluded": false,
          "summary": "An array of `Subcommand` objects representing all the subcommands that exist beneath the current command.\n    *\nTo support large CLI tools, `Subcommands` can be nested recursively.",
          "parameters": [],
          "optional": true,
          "declaration": "subcommands?: Subcommand[]",
          "examples": [
            "A CLI tool like `aws` is composed of many top-level subcommands (`s3`, `ec2`, `eks`...), each of which include child subcommands of their own."
          ],
          "hasDocComment": true
        },
        {
          "name": "requiresSubcommand",
          "excluded": false,
          "summary": "Specifies whether the command requires a subcommand. This is false by default.\n\nA space will always be inserted after this command if `requiresSubcommand` is true.\nIf the property is omitted, a space will be inserted if there is at least one required argument.",
          "parameters": [],
          "optional": true,
          "declaration": "requiresSubcommand?: boolean",
          "examples": [],
          "hasDocComment": true
        },
        {
          "name": "options",
          "excluded": false,
          "summary": "An array of `Option` objects representing the options that are available on this subcommand.",
          "parameters": [],
          "optional": true,
          "declaration": "options?: Option[]",
          "examples": [
            "A command like `git commit` accepts various flags and options, such as `--message` and `--all`. These `Option` objects would be included in the `options` field."
          ],
          "hasDocComment": true
        },
        {
          "name": "args",
          "excluded": false,
          "summary": "An array of `Arg` objects representing the various parameters or \"arguments\" that can be passed to this subcommand.",
          "parameters": [],
          "optional": true,
          "declaration": "args?: Arg | Arg[]",
          "examples": [],
          "hasDocComment": true
        },
        {
          "name": "filterStrategy",
          "excluded": false,
          "summary": "This option allows to enforce the suggestion filtering strategy for a specific subcommand.",
          "discussion": "Users always want to have the most accurate results at the top of the suggestions list.\nFor example we can enable fuzzy search on a subcommand that always requires fuzzy search to show the best suggestions.\nThis property is also useful when subcommands or options have a prefix (e.g. the npm package scope) because enabling fuzzy search users can omit that part (see the second example below)",
          "parameters": [],
          "optional": true,
          "declaration": "filterStrategy?: \"fuzzy\" | \"prefix\" | \"default\"",
          "examples": [
            "yarn workspace [name] with fuzzy search is way more useful since we can omit the npm package scope",
            "fig settings <setting name> uses fuzzy search to prevent having to add the `autocomplete.` prefix to each searched setting\n```typescript\nconst figSpec: Fig.Spec {\n  name: \"fig\",\n  subcommands: [\n    {\n      name: \"settings\",\n      filterStrategy: \"fuzzy\",\n      subcommands: [\n        {\n          name: \"autocomplete.theme\", // if a user writes `fig settings theme` it gets the correct suggestions\n        },\n        // ... other settings\n      ]\n    },\n    // ... other fig subcommands\n  ]\n}\n```"
          ],
          "hasDocComment": true
        },
        {
          "name": "additionalSuggestions",
          "excluded": false,
          "summary": "A list of Suggestion objects that are appended to the suggestions shown beneath a subcommand.",
          "discussion": "You can use this field to suggest common workflows.",
          "parameters": [],
          "optional": true,
          "declaration": "additionalSuggestions?: (string | Suggestion)[]",
          "examples": [],
          "hasDocComment": true
        },
        {
          "name": "loadSpec",
          "excluded": false,
          "summary": "Dynamically load another completion spec at runtime.",
          "returns": "A `SpecLocation` object or an array of `SpecLocation` objects.",
          "discussion": "`loadSpec` can be invoked as string (recommended) or a function (advanced).\n\nThe API tells the autocomplete engine where to look for a completion spec. If you pass a string, the engine will attempt to locate a matching spec that is hosted by Fig.",
          "parameters": [
            {
              "name": "tokens",
              "description": "a tokenized array of the text the user has typed in the shell."
            },
            {
              "name": "executeShellCommand",
              "description": "an async function that can execute a shell command on behalf of the user. The output is a string."
            }
          ],
          "optional": true,
          "declaration": "loadSpec?:\n  | string\n  | Subcommand\n  | ((\n      token: string,\n      executeShellCommand: (\n        commandToExecute: string,\n        cwd?: string\n      ) => Promise<string>\n    ) => Promise<SpecLocation | SpecLocation[] | Subcommand>)",
          "examples": [
            "Suppose you have an internal CLI tool that wraps `kubectl`. Instead of copying the `kubectl` completion spec, you can include the spec at runtime.\n```typescript\n{\n  name: \"kube\",\n  description: \"a wrapper around kubectl\"\n  loadSpec: \"kubectl\"\n}\n```",
            "In the `aws` completion spec, `loadSpec` is used to optimize performance. The completion spec is split into multiple files, each of which can be loaded separately.\n```typescript\n{\n  name: \"s3\",\n  loadSpec: \"aws/s3\"\n}\n```"
          ],
          "hasDocComment": true
        },
        {
          "name": "generateSpec",
          "excluded": false,
          "summary": "Dynamically *generate* a `Subcommand` object a runtime. The generated `Subcommand` is merged with the current subcommand.",
          "returns": "a `Fig.Spec` object",
          "discussion": "This API is often used by CLI tools where the structure of the CLI tool is not *static*. For instance, if the tool can be extended by plugins or otherwise shows different subcommands or options depending on the environment.",
          "parameters": [
            {
              "name": "tokens",
              "description": "a tokenized array of the text the user has typed in the shell."
            },
            {
              "name": "executeShellCommand",
              "description": "an async function that can execute a shell command on behalf of the user. The output is a string."
            }
          ],
          "optional": true,
          "declaration": "generateSpec?: (\n  tokens: string[],\n  executeShellCommand: (\n    commandToExecute: string,\n    cwd?: string\n  ) => Promise<string>\n) => Promise<\n  | Subcommand\n  | ((version?: string) => Subcommand)\n  | ((version?: string) => {\n      versionedSpecPath: string\n      version?: string\n    })\n>",
          "examples": [
            "The `python` spec uses `generateSpec` to include the`django-admin` spec if `django manage.py` exists.\n```typescript\ngenerateSpec: async (tokens, executeShellCommand) => {\n   // Load the contents of manage.py\n   const managePyContents = await executeShellCommand(\"cat manage.py\");\n   // Heuristic to determine if project uses django\n   if (managePyContents.contains(\"django\")) {\n     return {\n       name: \"python\",\n       subcommands: [{ name: \"manage.py\", loadSpec: \"django-admin\" }],\n     };\n   }\n },\n```"
          ],
          "hasDocComment": true
        },
        {
          "name": "parserDirectives",
          "excluded": false,
          "summary": "Configure how the autocomplete engine will map the raw tokens to a given completion spec.",
          "parameters": [
            {
              "name": "flagsArePosixNoncompliant",
              "description": "Indicates that flags with one hyphen may have *more* than one character. Enabling this directive, turns off support for option chaining."
            },
            {
              "name": "optionsMustPrecedeArguments",
              "description": "Options will not be suggested after any argument of the Subcommand has been typed."
            },
            {
              "name": "optionArgSeparators",
              "description": "Indicate that options which take arguments will require one of the specified separators between the 'verbose' option name and the argument."
            }
          ],
          "optional": true,
          "declaration": "parserDirectives?: {\n  flagsArePosixNoncompliant?: boolean\n  optionsMustPrecedeArguments?: boolean\n  optionArgSeparators?: string | string[]\n}",
          "examples": [
            "The `-work` option from the `go` spec is parsed as a single flag when `parserDirectives.flagsArePosixNoncompliant` is set to true. Normally, this would be chained and parsed as `-w -o -r -k` if `flagsArePosixNoncompliant` is not set to true."
          ],
          "hasDocComment": true
        }
      ],
      "inheritedMembers": [
        {
          "name": "displayName",
          "excluded": false,
          "summary": "The string that is displayed in the UI for a given suggestion.",
          "parameters": [],
          "optional": true,
          "declaration": "displayName?: string",
          "examples": [
            "The npm CLI has a subcommand called `install`. If we wanted\nto display some custom text like `Install an NPM package ðŸ“¦` we would set\n`name: \"install\"` and `displayName: \"Install an NPM package ðŸ“¦\"`"
          ],
          "default": "the name prop",
          "hasDocComment": true
        },
        {
          "name": "insertValue",
          "excluded": false,
          "summary": "The value that's inserted into the terminal when a user presses enter/tab or clicks on a menu item.",
          "discussion": "You can use `\\n` to insert a newline or `\\b` to insert a backspace.\nYou can also optionally specify {cursor} in the string and Fig will automatically place the cursor there after insert.",
          "parameters": [],
          "optional": true,
          "declaration": "insertValue?: string",
          "examples": [
            "For the `git commit` subcommand, the `-m` option has an insert value of `-m '{cursor}'`"
          ],
          "default": "The value of the name prop.",
          "hasDocComment": true
        },
        {
          "name": "replaceValue",
          "excluded": false,
          "summary": "When the suggestion is inserted, replace the command with this string",
          "discussion": "You can use `\\n` to insert a newline or `\\b` to insert a backspace.\nYou can also optionally specify {cursor} in the string and Fig will automatically place the cursor there after insert.\nNote that currently the entire edit buffer will be replaced. Eventually, only the root command will be replaced, preserving pipes and continuations.",
          "parameters": [],
          "optional": true,
          "declaration": "replaceValue?: string",
          "examples": [],
          "hasDocComment": true
        },
        {
          "name": "description",
          "excluded": false,
          "summary": "The text that gets rendered at the bottom of the autocomplete box (or the side if you hit âŒ˜i)",
          "parameters": [],
          "optional": true,
          "declaration": "description?: string",
          "examples": ["\"Your commit message\""],
          "hasDocComment": true
        },
        {
          "name": "icon",
          "excluded": false,
          "summary": "The icon that is rendered is based on the type.",
          "discussion": "Icons can be a 1 character string, a URL, or Fig's [icon protocol](https://fig.io/docs/reference/suggestion/icon-api) (fig://) which lets you generate\ncolorful and fun systems icons.",
          "parameters": [],
          "optional": true,
          "declaration": "icon?: string",
          "examples": [
            "`A`",
            "`ðŸ˜Š`",
            "`https://www.herokucdn.com/favicon.ico`",
            "`fig://icon?type=file`"
          ],
          "default": "related to the type of the object (e.g. `Suggestion`, `Subcommand`, `Option`, `Arg`)",
          "hasDocComment": true
        },
        {
          "name": "isDangerous",
          "excluded": false,
          "summary": "Specifies whether the suggestion is \"dangerous\".",
          "discussion": "If true, Fig will not enable its autoexecute functionality. Autoexecute means if a user selects a suggestion it will insert the text and run the command. We signal this by changing the icon to red.\nSetting `isDangerous` to `true` will make it harder for a user to accidentally run a dangerous command.",
          "parameters": [],
          "optional": true,
          "declaration": "isDangerous?: boolean",
          "examples": [
            "This is used in the `rm` spec. Why? Because we don't want users to accidentally delete their files so we make it just a little bit harder..."
          ],
          "default": "false",
          "hasDocComment": true
        },
        {
          "name": "priority",
          "excluded": false,
          "summary": "The number used to rank suggestions in autocomplete. Number must be from 0-100. Higher priorities rank higher.",
          "discussion": "Fig ranks suggestions by recency. To do this, we check if a suggestion has been selected before. If yes and the suggestions has:\n- a priority between 50-75, the priority will be replaced with 75, then we will add the timestamp of when that suggestion was selected as a decimal.\n- a priority outside of 50-75, the priority will be increased by the timestamp of when that suggestion was selected as a decimal.\nIf it has not been selected before, Fig will keep the same priority as was set in the completion spec\nIf it was not set in the spec, it will default to 50.",
          "parameters": [],
          "optional": true,
          "declaration": "priority?: number",
          "examples": [
            "Let's say a user has previously selected a suggestion at unix timestamp 1634087677:\n    - If completion spec did not set a priority (Fig treats this as priority 50), its priority would change to 75 + 0.1634087677 = 75.1634087677;\n    - If completion spec set a priority of 49 or less, its priority would change to 49 + 0.1634087677 = 49.1634087677;\n    - If completion spec set a priority of 76 or more, its priority would change to 76 + 0.1634087677 = 76.1634087677;\n    - If a user had never selected a suggestion, then its priority would just stay as is (or if not set, default to 50).",
            "If you want your suggestions to always be:\n    - at the top order, rank them 76 or above.\n    - at the bottom, rank them 49 or below"
          ],
          "default": "50",
          "hasDocComment": true
        },
        {
          "name": "hidden",
          "excluded": false,
          "summary": "Specifies whether a suggestion should be hidden from results.",
          "discussion": "Fig will only show it if the user exactly types the name.",
          "parameters": [],
          "optional": true,
          "declaration": "hidden?: boolean",
          "examples": [
            "The \"-\" suggestion is hidden in the `cd` spec. You will only see it if you type exactly  `cd -`"
          ],
          "default": "false",
          "hasDocComment": true
        },
        {
          "name": "deprecated",
          "excluded": false,
          "summary": "Specifies whether a suggestion is deprecated.",
          "discussion": "It is possible to specify a suggestion to replace the deprecated one.\n- The `description` of the deprecated object (e.g `deprecated: { description: 'The --no-ansi option has been deprecated in v2' }`) is used to provide infos about the deprecation.\n- `deprecated: true` and `deprecated: { }` behave the same and will just display the suggestion as deprecated.",
          "parameters": [],
          "optional": true,
          "declaration": "deprecated?: boolean | Omit<BaseSuggestion, \"deprecated\">",
          "examples": [
            "```js\ndeprecated: { insertValue: '--ansi never', description: 'The --no-ansi option has been deprecated in v2' }\n```"
          ],
          "hasDocComment": true
        }
      ]
    },
    {
      "name": "Option",
      "hasDocComment": true,
      "extends": ["BaseSuggestion"],
      "members": [
        {
          "name": "name",
          "excluded": false,
          "summary": "The exact name of the subcommand as defined in the CLI tool.",
          "discussion": "Fig's parser relies on your option name being exactly what the user would type. (e.g. if the user types `git \"-m\"`, you must have `name: \"-m\"` and not something like `name: \"your message\"` or even with an `=` sign like`name: \"-m=\"`)\n\nIf you want to customize what the text the popup says, use `displayName`.\n\nThe name prop in an Option object compiles down to the name prop in a Suggestion object\n\nFinal note: the name prop can be a string (most common) or an array of strings",
          "parameters": [],
          "optional": false,
          "declaration": "name: string | string[]",
          "examples": [
            "For `git commit -m` in the, message option nested beneath `commit` would have `name: [\"-m\", \"--message\"]`",
            "For `ls -l` the `-l` option would have `name: \"-l\"`"
          ],
          "hasDocComment": true
        },
        {
          "name": "args",
          "excluded": false,
          "summary": "An array of arg objects or a single arg object",
          "discussion": "If a subcommand takes an argument, please at least include an empty Arg Object. (e.g. `{ }`). Why? If you don't, Fig will assume the subcommand does not take an argument. When the user types their argument\nIf the argument is optional, signal this by saying `isOptional: true`.",
          "parameters": [],
          "optional": true,
          "declaration": "args?: Arg | Arg[]",
          "examples": [
            "`npm run` takes one mandatory argument. This can be represented by `args: { }`",
            "`git push` takes two optional arguments. This can be represented by: `args: [{ isOptional: true }, { isOptional: true }]`",
            "`git clone` takes one mandatory argument and one optional argument. This can be represented by: `args: [{ }, { isOptional: true }]`"
          ],
          "hasDocComment": true
        },
        {
          "name": "isPersistent",
          "excluded": false,
          "summary": "Signals whether an option is persistent, meaning that it will still be available\nas an option for all child subcommands.",
          "discussion": "As of now there is no way to disable this\npersistence for certain children. Also see\nhttps://github.com/spf13/cobra/blob/master/user_guide.md#persistent-flags.",
          "parameters": [],
          "optional": true,
          "declaration": "isPersistent?: boolean",
          "examples": [
            "Say the `git` spec had an option at the top level with `{ name: \"--help\", isPersistent: true }`.\nThen the spec would recognize both `git --help` and `git commit --help`\nas a valid as we are passing the `--help` option to all `git` subcommands."
          ],
          "default": "false",
          "hasDocComment": true
        },
        {
          "name": "isRequired",
          "excluded": false,
          "summary": "Signals whether an option is required.",
          "parameters": [],
          "optional": true,
          "declaration": "isRequired?: boolean",
          "examples": ["The `-m` option of `git commit` is required"],
          "default": "false (option is NOT required)",
          "hasDocComment": true
        },
        {
          "name": "requiresEquals",
          "excluded": false,
          "summary": "Signals whether an equals sign is required to pass an argument to an option (e.g. `git commit --message=\"msg\"`)",
          "parameters": [],
          "deprecated": "use `requiresSeparator` instead",
          "optional": true,
          "declaration": "requiresEquals?: boolean",
          "examples": [
            "When `requiresEqual: true` the user MUST do `--opt=value` and cannot do `--opt value`"
          ],
          "default": "false (does NOT require an equal)",
          "hasDocComment": true
        },
        {
          "name": "requiresSeparator",
          "excluded": false,
          "summary": "Signals whether one of the separators specified in parserDirectives is required to pass an argument to an option (e.g. `git commit --message[separator]\"msg\"`)\nIf set to true this will automatically insert an equal after the option name.\nIf set to a separator (string) this will automatically insert the separator specified after the option name.",
          "parameters": [],
          "optional": true,
          "declaration": "requiresSeparator?: boolean | string",
          "examples": [
            "When `requiresSeparator: true` the user MUST do `--opt=value` and cannot do `--opt value`",
            "When `requiresSeparator: ':'` the user MUST do `--opt:value` and cannot do `--opt value`"
          ],
          "default": "false (does NOT require a separator)",
          "hasDocComment": true
        },
        {
          "name": "isRepeatable",
          "excluded": false,
          "summary": "Signals whether an option can be passed multiple times.",
          "discussion": "Passing `isRepeatable: true` will allow an option to be passed any number\nof times, while passing `isRepeatable: 2` will allow it to be passed\ntwice, etc. Passing `isRepeatable: false` is the same as passing\n`isRepeatable: 1`.\n\nIf you explicitly specify the isRepeatable option in a spec, this\nconstraint will be enforced at the parser level, meaning after the option\n(say `-o`) has been passed the maximum number of times, Fig's parser will\nnot recognize `-o` as an option if the user types it again.",
          "parameters": [],
          "optional": true,
          "declaration": "isRepeatable?: boolean | number",
          "examples": [
            "In `npm install` doesn't specify `isRepeatable` for `{ name: [\"-D\", \"--save-dev\"] }`.\nWhen the user types `npm install -D`, Fig will no longer suggest `-D`.\nIf the user types `npm install -D -D`. Fig will still parse the second\n`-D` as an option.\n\nSuppose `npm install` explicitly specified `{ name: [\"-D\", \"--save-dev\"], isRepeatable: false }`.\nNow if the user types `npm install -D -D`, Fig will instead parse the second\n`-D` as the argument to the `install` subcommand instead of as an option.",
            "SSH has `{ name: \"-v\", isRepeatable: 3 }`. When the user types `ssh -vv`, Fig\nwill still suggest `-v`, when the user types `ssh -vvv` Fig will stop\nsuggesting `-v` as an option. Finally if the user types `ssh -vvvv` Fig's\nparser will recognize that this is not a valid string of chained options\nand will treat this as an argument to `ssh`."
          ],
          "default": "false (option is NOT repeatable)",
          "hasDocComment": true
        },
        {
          "name": "exclusiveOn",
          "excluded": false,
          "summary": "Signals whether an option is mutually exclusive with other options (ie if the user has this option, Fig should not show the options specified).",
          "discussion": "Options that are mutually exclusive with flags the user has already passed will not be shown in the suggestions list.",
          "parameters": [],
          "optional": true,
          "declaration": "exclusiveOn?: string[]",
          "examples": [
            "You might see `[-a | --interactive | --patch]` in a man page. This means each of these options are mutually exclusive on each other.\nIf we were defining the exclusive prop of the \"-a\" option, then we would have `exclusive: [\"--interactive\", \"--patch\"]`"
          ],
          "default": "false",
          "hasDocComment": true
        },
        {
          "name": "dependsOn",
          "excluded": false,
          "summary": "Signals whether an option depends on other options (ie if the user has this option, Fig should only show these options until they are all inserted).",
          "discussion": "If the user has an unmet dependency for a flag they've already typed, this dependency will have boosted priority in the suggestion list.",
          "parameters": [],
          "optional": true,
          "declaration": "dependsOn?: string[]",
          "examples": [
            "In a tool like firebase, we may want to delete a specific extension. The command might be `firebase delete --project ABC --extension 123` This would mean we delete the 123 extension from the ABC project.\nIn this case, `--extension` dependsOn `--project`"
          ],
          "default": "false",
          "hasDocComment": true
        }
      ],
      "inheritedMembers": [
        {
          "name": "displayName",
          "excluded": false,
          "summary": "The string that is displayed in the UI for a given suggestion.",
          "parameters": [],
          "optional": true,
          "declaration": "displayName?: string",
          "examples": [
            "The npm CLI has a subcommand called `install`. If we wanted\nto display some custom text like `Install an NPM package ðŸ“¦` we would set\n`name: \"install\"` and `displayName: \"Install an NPM package ðŸ“¦\"`"
          ],
          "default": "the name prop",
          "hasDocComment": true
        },
        {
          "name": "insertValue",
          "excluded": false,
          "summary": "The value that's inserted into the terminal when a user presses enter/tab or clicks on a menu item.",
          "discussion": "You can use `\\n` to insert a newline or `\\b` to insert a backspace.\nYou can also optionally specify {cursor} in the string and Fig will automatically place the cursor there after insert.",
          "parameters": [],
          "optional": true,
          "declaration": "insertValue?: string",
          "examples": [
            "For the `git commit` subcommand, the `-m` option has an insert value of `-m '{cursor}'`"
          ],
          "default": "The value of the name prop.",
          "hasDocComment": true
        },
        {
          "name": "replaceValue",
          "excluded": false,
          "summary": "When the suggestion is inserted, replace the command with this string",
          "discussion": "You can use `\\n` to insert a newline or `\\b` to insert a backspace.\nYou can also optionally specify {cursor} in the string and Fig will automatically place the cursor there after insert.\nNote that currently the entire edit buffer will be replaced. Eventually, only the root command will be replaced, preserving pipes and continuations.",
          "parameters": [],
          "optional": true,
          "declaration": "replaceValue?: string",
          "examples": [],
          "hasDocComment": true
        },
        {
          "name": "description",
          "excluded": false,
          "summary": "The text that gets rendered at the bottom of the autocomplete box (or the side if you hit âŒ˜i)",
          "parameters": [],
          "optional": true,
          "declaration": "description?: string",
          "examples": ["\"Your commit message\""],
          "hasDocComment": true
        },
        {
          "name": "icon",
          "excluded": false,
          "summary": "The icon that is rendered is based on the type.",
          "discussion": "Icons can be a 1 character string, a URL, or Fig's [icon protocol](https://fig.io/docs/reference/suggestion/icon-api) (fig://) which lets you generate\ncolorful and fun systems icons.",
          "parameters": [],
          "optional": true,
          "declaration": "icon?: string",
          "examples": [
            "`A`",
            "`ðŸ˜Š`",
            "`https://www.herokucdn.com/favicon.ico`",
            "`fig://icon?type=file`"
          ],
          "default": "related to the type of the object (e.g. `Suggestion`, `Subcommand`, `Option`, `Arg`)",
          "hasDocComment": true
        },
        {
          "name": "isDangerous",
          "excluded": false,
          "summary": "Specifies whether the suggestion is \"dangerous\".",
          "discussion": "If true, Fig will not enable its autoexecute functionality. Autoexecute means if a user selects a suggestion it will insert the text and run the command. We signal this by changing the icon to red.\nSetting `isDangerous` to `true` will make it harder for a user to accidentally run a dangerous command.",
          "parameters": [],
          "optional": true,
          "declaration": "isDangerous?: boolean",
          "examples": [
            "This is used in the `rm` spec. Why? Because we don't want users to accidentally delete their files so we make it just a little bit harder..."
          ],
          "default": "false",
          "hasDocComment": true
        },
        {
          "name": "priority",
          "excluded": false,
          "summary": "The number used to rank suggestions in autocomplete. Number must be from 0-100. Higher priorities rank higher.",
          "discussion": "Fig ranks suggestions by recency. To do this, we check if a suggestion has been selected before. If yes and the suggestions has:\n- a priority between 50-75, the priority will be replaced with 75, then we will add the timestamp of when that suggestion was selected as a decimal.\n- a priority outside of 50-75, the priority will be increased by the timestamp of when that suggestion was selected as a decimal.\nIf it has not been selected before, Fig will keep the same priority as was set in the completion spec\nIf it was not set in the spec, it will default to 50.",
          "parameters": [],
          "optional": true,
          "declaration": "priority?: number",
          "examples": [
            "Let's say a user has previously selected a suggestion at unix timestamp 1634087677:\n    - If completion spec did not set a priority (Fig treats this as priority 50), its priority would change to 75 + 0.1634087677 = 75.1634087677;\n    - If completion spec set a priority of 49 or less, its priority would change to 49 + 0.1634087677 = 49.1634087677;\n    - If completion spec set a priority of 76 or more, its priority would change to 76 + 0.1634087677 = 76.1634087677;\n    - If a user had never selected a suggestion, then its priority would just stay as is (or if not set, default to 50).",
            "If you want your suggestions to always be:\n    - at the top order, rank them 76 or above.\n    - at the bottom, rank them 49 or below"
          ],
          "default": "50",
          "hasDocComment": true
        },
        {
          "name": "hidden",
          "excluded": false,
          "summary": "Specifies whether a suggestion should be hidden from results.",
          "discussion": "Fig will only show it if the user exactly types the name.",
          "parameters": [],
          "optional": true,
          "declaration": "hidden?: boolean",
          "examples": [
            "The \"-\" suggestion is hidden in the `cd` spec. You will only see it if you type exactly  `cd -`"
          ],
          "default": "false",
          "hasDocComment": true
        },
        {
          "name": "deprecated",
          "excluded": false,
          "summary": "Specifies whether a suggestion is deprecated.",
          "discussion": "It is possible to specify a suggestion to replace the deprecated one.\n- The `description` of the deprecated object (e.g `deprecated: { description: 'The --no-ansi option has been deprecated in v2' }`) is used to provide infos about the deprecation.\n- `deprecated: true` and `deprecated: { }` behave the same and will just display the suggestion as deprecated.",
          "parameters": [],
          "optional": true,
          "declaration": "deprecated?: boolean | Omit<BaseSuggestion, \"deprecated\">",
          "examples": [
            "```js\ndeprecated: { insertValue: '--ansi never', description: 'The --no-ansi option has been deprecated in v2' }\n```"
          ],
          "hasDocComment": true
        }
      ]
    },
    {
      "name": "Arg",
      "hasDocComment": true,
      "extends": [],
      "members": [
        {
          "name": "name",
          "excluded": false,
          "summary": "The name of an argument. This is different to the `name` prop for subcommands, options, and suggestion objects so please read carefully.\nThis `name` prop signals a normal, human readable string. It usually signals to the user the type of argument they are inserting if there are no available suggestions.\nUnlike subcommands and options, Fig does NOT use this value for parsing. Therefore, it can be whatever you want.",
          "parameters": [],
          "optional": true,
          "declaration": "name?: string",
          "examples": [
            "The name prop for the `git commit -m <msg>` arg object is \"msg\". But you could also make it \"message\" or \"your message\". It is only used for description purposes (you see it when you type the message), not for parsing!"
          ],
          "hasDocComment": true
        },
        {
          "name": "description",
          "excluded": false,
          "summary": "The text that gets rendered at the bottom of the autocomplete box a) when the user is inputting an argument and there are no suggestions and b) for all generated suggestions for an argument\nKeep it short and direct!",
          "parameters": [],
          "optional": true,
          "declaration": "description?: string",
          "examples": ["\"Your commit message\""],
          "hasDocComment": true
        },
        {
          "name": "isDangerous",
          "excluded": false,
          "summary": "Specifies whether the suggestions generated for this argument are \"dangerous\".",
          "discussion": "If true, Fig will not enable its autoexecute functionality. Autoexecute means if a user selects a suggestion it will insert the text and run the command. We signal this by changing the icon to red.\nTurning on isDangerous will make it harder for a user to accidentally run a dangerous command.",
          "parameters": [],
          "optional": true,
          "declaration": "isDangerous?: boolean",
          "examples": ["This is used for all arguments in the `rm` spec."],
          "default": "false",
          "hasDocComment": true
        },
        {
          "name": "suggestions",
          "excluded": false,
          "summary": "A list of Suggestion objects that are shown when a user is typing an argument.",
          "discussion": "These suggestions are static meaning you know them beforehand and they are not generated at runtime. If you want to generate suggestions at runtime, use a generator",
          "parameters": [],
          "optional": true,
          "declaration": "suggestions?: (string | Suggestion)[]",
          "examples": [
            "For `git reset <branch or commit>`, a two common arguments to pass are \"head\" and \"head^\". Therefore, the spec suggests both of these by using the suggestion prop"
          ],
          "hasDocComment": true
        },
        {
          "name": "template",
          "excluded": false,
          "summary": "A template which is a single TemplateString or an array of TemplateStrings",
          "discussion": "Templates are generators prebuilt by Fig. Here are the three templates:\n- filepaths: show folders and filepaths. Allow autoexecute on filepaths\n- folders: show folders only. Allow autoexecute on folders\n- history: show suggestions for all items in history matching this pattern\n- help: show subcommands. Only includes the 'siblings' of the nearest 'parent' subcommand",
          "parameters": [],
          "optional": true,
          "declaration": "template?:\n  | (\"filepaths\" | \"folders\" | \"history\" | \"help\")\n  | (\"filepaths\" | \"folders\" | \"history\" | \"help\")[]",
          "examples": [
            "`cd` uses the \"folders\" template",
            "`ls` used  [\"filepaths\", \"folders\"]. Why both? Because if I `ls` a directory, we want to enable a user to autoexecute on this directory. If we just did \"filepaths\" they couldn't autoexecute."
          ],
          "hasDocComment": true
        },
        {
          "name": "generators",
          "excluded": false,
          "summary": "Generators let you dynamically generate suggestions for arguments by running shell commands on a user's device.\n\nThis takes a single generator or an array of generators",
          "parameters": [],
          "optional": true,
          "declaration": "generators?: Generator | Generator[]",
          "examples": [],
          "hasDocComment": true
        },
        {
          "name": "filterStrategy",
          "excluded": false,
          "summary": "This option allows to enforce the suggestion filtering strategy for a specific argument suggestions.",
          "discussion": "Users always want to have the most accurate results at the top of the suggestions list.\nFor example we can enable fuzzy search on an argument that always requires fuzzy search to show the best suggestions.\nThis property is also useful when argument suggestions have a prefix (e.g. the npm package scope) because enabling fuzzy search users can omit that part (see the second example below)",
          "parameters": [],
          "optional": true,
          "declaration": "filterStrategy?: \"fuzzy\" | \"prefix\" | \"default\"",
          "examples": [
            "npm uninstall [packages...] uses fuzzy search to allow searching for installed packages ignoring the package scope\n```typescript\nconst figSpec: Fig.Spec {\n  name: \"npm\",\n  subcommands: [\n    {\n      args: {\n        name: \"packages\",\n        filterStrategy: \"fuzzy\", // search in suggestions provided by the generator (in this case) using fuzzy search\n        generators: generateNpmDeps,\n        isVariadic: true,\n      },\n    },\n    // ... other npm commands\n  ],\n}\n```"
          ],
          "hasDocComment": true
        },
        {
          "name": "suggestCurrentToken",
          "excluded": false,
          "summary": "Provide a suggestion at the top of the list with the current token that is being typed by the user.",
          "parameters": [],
          "optional": true,
          "declaration": "suggestCurrentToken?: boolean",
          "examples": [],
          "hasDocComment": true
        },
        {
          "name": "isVariadic",
          "excluded": false,
          "summary": "Specifies that the argument is variadic and therefore repeats infinitely.",
          "discussion": "Man pages represent variadic arguments with an ellipsis e.g. `git add <pathspec...>`",
          "parameters": [],
          "optional": true,
          "declaration": "isVariadic?: boolean",
          "examples": [
            "`echo` takes a variadic argument (`echo hello world ...`)",
            "`git add` also takes a variadic argument"
          ],
          "hasDocComment": true
        },
        {
          "name": "optionsCanBreakVariadicArg",
          "excluded": false,
          "summary": "Specifies whether options can interrupt variadic arguments. There is\nslightly different behavior when this is used on an option argument and\non a subcommand argument:\n\n- When an option breaks a *variadic subcommand argument*, after the option\nand any arguments are parsed, the parser will continue parsing variadic\narguments to the subcommand\n- When an option breaks a *variadic option argument*, after the breaking\noption and any arguments are parsed, the original variadic options\narguments will be terminated. See the second examples below for details.",
          "parameters": [],
          "optional": true,
          "declaration": "optionsCanBreakVariadicArg?: boolean",
          "examples": [
            "When true for git add's argument:\n`git add file1 -v file2` will interpret `-v` as an option NOT an\nargument, and will continue interpreting file2 as a variadic argument to\nadd after",
            "When true for -T's argument, where -T is a variadic list of tags:\n`cmd -T tag1 tag2 -p project tag3` will interpret `-p` as an option, but\nwill then terminate the list of tags. So tag3 is not parsed as an\nargument to `-T`, but rather as a subcommand argument to `cmd` if `cmd`\ntakes any arguments.",
            "When false:\n`echo hello -n world` will treat -n as an argument NOT an option.\nHowever, in `echo -n hello world` it will treat -n as an option as\nvariadic arguments haven't started yet"
          ],
          "default": "true",
          "hasDocComment": true
        },
        {
          "name": "isOptional",
          "excluded": false,
          "summary": "`true` if an argument is optional (ie the CLI spec says it is not mandatory to include an argument, but you can if you want to).",
          "discussion": "NOTE: It is important you include this for our parsing. If you don't, Fig will assume the argument is mandatory. When we assume an argument is mandatory, we force the user to input the argument and hide all other suggestions.",
          "parameters": [],
          "optional": true,
          "declaration": "isOptional?: boolean",
          "examples": ["`git push [remote] [branch]` takes two optional args."],
          "hasDocComment": true
        },
        {
          "name": "isCommand",
          "excluded": false,
          "summary": "Syntactic sugar over the `loadSpec` prop.",
          "discussion": "Specifies that the argument is an entirely new command which Fig should start completing on from scratch.",
          "parameters": [],
          "optional": true,
          "declaration": "isCommand?: boolean",
          "examples": [
            "`time` and `builtin` have only one argument and this argument has the `isCommand` property. If I type `time git`, Fig will load up the git completion spec because the isCommand property is set."
          ],
          "hasDocComment": true
        },
        {
          "name": "isScript",
          "excluded": false,
          "summary": "The same as the `isCommand` prop, except Fig will look for a completion spec in the `.fig/autocomplete/build` folder in the user's current working directory.",
          "discussion": "See our docs for more on building completion specs for local scripts [Fig for Teams](https://fig.io/docs/)",
          "parameters": [],
          "optional": true,
          "declaration": "isScript?: boolean",
          "examples": [
            "`python` take one argument which is a `.py` file. If I have a `main.py` file on my desktop and my current working directory is my desktop, if I type `python main.py[space]` Fig will look for a completion spec in `~/Desktop/.fig/autocomplete/build/main.py.js`"
          ],
          "hasDocComment": true
        },
        {
          "name": "isModule",
          "excluded": false,
          "summary": "The same as the `isCommand` prop, except you specify a string to prepend to what the user inputs and fig will load the completion spec accordingly.",
          "discussion": "If isModule: \"python/\", Fig would load up the `python/USER_INPUT.js` completion spec from the `~/.fig/autocomplete` folder.",
          "parameters": [],
          "deprecated": "use `loadSpec` instead",
          "optional": true,
          "declaration": "isModule?: string",
          "examples": [
            "For `python -m`, the user can input a specific module such as http.server. Each module is effectively a mini CLI tool that should have its own completions. Therefore the argument object for -m has `isModule: \"python/\"`. Whatever the modules user inputs, Fig will look under the `~/.fig/autocomplete/python/` directory for completion spec."
          ],
          "hasDocComment": true
        },
        {
          "name": "debounce",
          "excluded": false,
          "summary": "This will debounce every keystroke event for this particular arg.",
          "discussion": "If there are no keystroke events after 100ms, Fig will execute all the generators in this arg and return the suggestions.",
          "parameters": [],
          "optional": true,
          "declaration": "debounce?: boolean",
          "examples": [
            "`npm install` and `pip install` send debounced network requests after inactive typing from users."
          ],
          "hasDocComment": true
        },
        {
          "name": "default",
          "excluded": false,
          "summary": "The default value for an optional argument.",
          "discussion": "Note: This is currently not used anywhere in Fig's autocomplete popup, but will be soon.",
          "parameters": [],
          "optional": true,
          "declaration": "default?: string",
          "examples": [],
          "hasDocComment": true
        },
        {
          "name": "loadSpec",
          "excluded": false,
          "summary": "See [`loadSpec` in Subcommand Object](https://fig.io/docs/reference/subcommand#loadspec).",
          "discussion": "There is a very high chance you want to use one of the following:\n1. `isCommand` (See [Arg Object](https://fig.io/docs/reference/arg#iscommand))\n2. `isScript` (See [Arg Object](https://fig.io/docs/reference/arg#isscript))",
          "parameters": [],
          "optional": true,
          "declaration": "loadSpec?:\n  | string\n  | Subcommand\n  | ((\n      token: string,\n      executeShellCommand: (\n        commandToExecute: string,\n        cwd?: string\n      ) => Promise<string>\n    ) => Promise<SpecLocation | SpecLocation[] | Subcommand>)",
          "examples": [],
          "hasDocComment": true
        },
        {
          "name": "parserDirectives",
          "excluded": false,
          "summary": "The `arg.parserDirective.alias` prop defines whether Fig's tokenizer should expand out an alias into separate tokens then offer completions accordingly.",
          "returns": "The expansion of the alias that Fig's bash parser will reparse as if it were typed out in full, rather than the alias.\n\nIf for some reason you know exactly what it will be, you may also just pass in the expanded alias, not a function that returns the expanded alias.",
          "discussion": "This is similar to how Fig is able to offer autocomplete for user defined shell aliases, but occurs at the completion spec level.",
          "parameters": [
            {
              "name": "token",
              "description": "The token that the user has just typed that is an alias for something else"
            },
            {
              "name": "executeShellCommand",
              "description": "an async function that allows you to execute a shell command on the user's system and get the output as a string."
            }
          ],
          "optional": true,
          "declaration": "parserDirectives?: {\n  alias?:\n    | string\n    | ((\n        token: string,\n        exec: (commandToExecute: string, cwd?: string) => Promise<string>\n      ) => Promise<string>)\n}",
          "examples": [
            "git takes git aliases. These aliases are defined in a user's gitconfig file. Let's say a user has an alias for `p=push`, then if a user typed `git p[space]`, this function would take the `p` token, return `push` and then offer suggestions as if the user had typed `git push[space]`",
            "`npm run <script>` also takes an arg called \"script\". This arg is technically an alias for another shell command that is specified in the package.json.\nIf the user typed `npm run start[space]`, the package.json had script `start=node index.js`, then Fig would start offering suggestions for as if you had just typed `node index.js[space]`\n\nNote: In both cases, the alias function is only used to expand a given alias NOT to generate the list of aliases. To generate a list of aliases, scripts etc, use a generator."
          ],
          "hasDocComment": true
        }
      ],
      "inheritedMembers": []
    },
    {
      "name": "Generator",
      "hasDocComment": true,
      "extends": [],
      "members": [
        {
          "name": "template",
          "excluded": false,
          "summary": "A template which is a single `TemplateString` or an array of `TemplateStrings`.",
          "discussion": "Templates are generators prebuilt by Fig. Here are the three templates:\n- filepaths: show folders and filepaths. Allow autoexecute on filepaths\n- folders: show folders only. Allow autoexecute on folders\n- history: show suggestions for all items in history matching this pattern\n- help: show subcommands. Only includes the 'siblings' of the nearest 'parent' subcommand",
          "parameters": [],
          "optional": true,
          "declaration": "template?:\n  | (\"filepaths\" | \"folders\" | \"history\" | \"help\")\n  | (\"filepaths\" | \"folders\" | \"history\" | \"help\")[]",
          "examples": [
            "`cd` uses the \"folders\" template",
            "`ls` uses  [\"filepaths\", \"folders\"]. Why both? Because if I `ls` a directory, we want to enable a user to autoexecute on this directory. If we just did \"filepaths\" they couldn't autoexecute."
          ],
          "hasDocComment": true
        },
        {
          "name": "filterTemplateSuggestions",
          "excluded": false,
          "summary": "A function to filter and modify suggestions returned by a template",
          "returns": "An array of `Suggestion` objects.",
          "parameters": [
            {
              "name": "templateSuggestions",
              "description": "the array of suggestion objects returned by the given template."
            }
          ],
          "optional": true,
          "declaration": "filterTemplateSuggestions?: (\n  param: Modify<\n    Suggestion,\n    {\n      name?: string\n      context:\n        | {\n            templateType: \"filepaths\"\n          }\n        | {\n            templateType: \"folders\"\n          }\n        | {\n            templateType: \"help\"\n          }\n        | ({\n            templateType: \"history\"\n          } & Partial<{\n            currentWorkingDirectory: string\n            time: number\n            exitCode: number\n            shell: string\n          }>)\n    }\n  >[]\n) => Suggestion[]",
          "examples": [
            "The python spec has an arg object which has a template for \"filepaths\". However, we don't want to suggest non `.py` files. Therefore, we take the output of the template, filter out all files that don't end in `.py`, keep all folders that end with `/` and return the list of suggestions."
          ],
          "hasDocComment": true
        },
        {
          "name": "script",
          "excluded": false,
          "summary": "The script / shell command you wish to run on the user's device at their shell session's current working directory.",
          "discussion": "You can either specify\n1. a string to be executed (like `ls` or `git branch`)\n2. a function to generate the string to be executed. The function takes in an array of tokens of the user input and should output a string. You use a function when the script you run is dependent upon one of the tokens the user has already input (for instance an app name, a Kubernetes token etc.)\nAfter executing the script, the output will be passed to one of `splitOn` or `postProcess` for further processing to produce suggestion objects.",
          "parameters": [],
          "optional": true,
          "declaration": "script?: string | ((param: string[]) => string)",
          "examples": [
            "`git checkout <branch>` takes one argument which is a git branch. Its arg object has a generator with a `script: \"git branch\"`. The output of this shell command is then passed into the postProcess function to generate the final suggestions."
          ],
          "hasDocComment": true
        },
        {
          "name": "scriptTimeout",
          "excluded": false,
          "summary": "Set the execution timeout of the command specified in the `script` prop.",
          "parameters": [],
          "optional": true,
          "declaration": "scriptTimeout?: number",
          "examples": [],
          "default": "5000",
          "hasDocComment": true
        },
        {
          "name": "postProcess",
          "excluded": false,
          "summary": "Process the string output from the `script` prop and return a list of suggestions",
          "returns": "An array of `Suggestion` objects.",
          "parameters": [
            {
              "name": "out",
              "description": "The output of the script that was executed on the user's device"
            },
            {
              "name": "tokens",
              "description": "a tokenized array of what the user has typed"
            }
          ],
          "optional": true,
          "declaration": "postProcess?: (out: string, tokens: string[]) => Suggestion[]",
          "examples": [],
          "hasDocComment": true
        },
        {
          "name": "splitOn",
          "excluded": false,
          "summary": "Syntactic sugar for `postProcess` function",
          "discussion": "This takes in the text output of `script`, splits it on the string you provide here, and then automatically generates an array of suggestion objects for each item.",
          "parameters": [],
          "optional": true,
          "declaration": "splitOn?: string",
          "examples": [
            "Specify `\\n` and Fig will split on new lines, and turn each line into a suggestion object with `name` prop equal to the value on the line."
          ],
          "hasDocComment": true
        },
        {
          "name": "trigger",
          "excluded": false,
          "summary": "A function run on every keystroke that determines whether Fig should invalidate its cached list of suggestions and instead regenerate its list of suggestions.",
          "returns": "A boolean of whether or not we should regenerate suggestions",
          "discussion": "A note on how Fig works: Suggestions vs Filtered Suggestions\nSuggestions: Whenever you type a space indicating the start of a new token, Fig will regenerate a new list of suggestions e.g. `git[space]` will generate a list of suggestions for every subcommand, option, and arg\nFiltered Suggestions: When you type within the same token (e.g. `git c` -> `git ch`), Fig takes the token you are currently typing in and uses it to filter over the list of suggestions you have cached. e.g. `git c`. The list of suggestions is the same as before, but the filtered suggestions are now `commit`, `clean`, `clone`, and `checkout`.\n\n**Why don't we recalculate suggestions on each keystroke?**\n1. It's expensive\n2. We don't need to. The caching works nicely\n\n**So what does the trigger do?**\nThe trigger function is run on every keystroke and tells us whether or not we should invalidate the cache and regenerate a list of suggestions.\nThe trigger function is almost always used with a `custom` generator and the `getQueryTerm` function to make the autocomplete experience really good (it's how suggestions for `cd` work)\nIt is especially beneficial when you want to generate suggestions for an argument contained inside a single string that is not separated by a space.\n\n**What is important to remember?**\nThis function looks at the CHANGE in a token, not the current state of the token. If my token goes from `desktop` to `desktop/`, should I regenerate suggestions? Remember, users can paste text so theoretically any change is possible. It is totally valid for oldToken to be an empty string and newToken to be a 50 character string!",
          "parameters": [
            {
              "name": "newToken",
              "description": "The new token that was just typed by the user e.g. \"desktop/\"\""
            },
            {
              "name": "oldToken",
              "description": "The old token that was there before e.g. \"desktop\""
            }
          ],
          "optional": true,
          "declaration": "trigger?:\n  | string\n  | ((newToken: string, oldToken: string) => boolean)\n  | {\n      /** Trigger on any change to the token */\n      on: \"change\"\n    }\n  | {\n      /** Trigger when the length of the token changes past a threshold */\n      on: \"threshold\"\n      length: number\n    }\n  | {\n      /** Trigger when the index of a string changes */\n      on: \"match\"\n      string: string | string[]\n    }",
          "examples": [
            "`chmod`: If I type `chmod u` we should generate suggestions for `u+x`, `u+r`, `u-w` etc. Whereas if I typed `chmod 7` we should generate suggestions for `755` or `777` etc.\nThe suggestion we generate depends on the new information we have. The oldToken was an empty string, the new token could be a `7` or a `u` etc...\n\n  All this function's job is to say whether or not we should generate new suggestions. It does not specify how to create these new suggestions. This is the job of the `script` or `custom` props. Annoyingly, you may have to implement some of the same parsing logic again. However, because this is javascript, just create a function so you don't have to repeat yourself :)\n\n  Note: yes, we could have generate a list of suggestions at the start for every single permutation of 777 or u+x etc, however, there are so many and this is just not performant!",
            "`cd`: Let's say a user has \"cd desktop\" currently typed then the user types a \"/\" so the changes to \"cd ~/desktop/\".\nThe old token is \"~/desktop\", new token is \"desktop/\". This is a perfect time for us to generate a new list of suggestions. We previously had all the folders in my ~ directory as suggestions, but after the total number of `/` in the tokens changed, we should trigger a new set of suggestions to be generated. This new set of suggestions should then generate suggestions for the desktop directory, not the ~ directory."
          ],
          "default": "`false`\nIt means that the function returns false ie we do not regenerate suggestion on each keystroke and instead, keep our cached list of suggestions while the user is editing the current token.",
          "hasDocComment": true
        },
        {
          "name": "getQueryTerm",
          "excluded": false,
          "summary": "A function that takes the token that the user has typed and determines which part of it should be used to filter over all the suggestions.",
          "returns": "The query term that Fig will use to filter over suggestions",
          "discussion": "Read the note above on how triggers work. Triggers and query term may seem similar but are actually different.\n\nThe `trigger` function defines when to regenerate new suggestions.\nThe `query` term defines what characters we should use to filter over these suggestions.\nThe `getQueryTerm` function defines the queryTerm",
          "parameters": [
            {
              "name": "token",
              "description": "The full token the user is currently typing"
            }
          ],
          "optional": true,
          "declaration": "getQueryTerm?: string | ((param: string) => string)",
          "examples": [
            "`cd` has a `getQueryTerm` function that takes the token the user has typed and returns everything after the last \"/\".\nif the user types cd `~/desktop/a`, the list of suggestions will be all the folders on the user's desktop. We want to filter over these folders with the query term `\"a\"` not `~/desktop/a`"
          ],
          "hasDocComment": true
        },
        {
          "name": "custom",
          "excluded": false,
          "summary": "An async function that is similar to the function version of `script`, however, it gives you full control.",
          "returns": "An array of suggestion objects",
          "discussion": "This function is effectively `script` and `postProcess` combined. It is very useful in combination with `trigger` and `getQueryTerm` to generate suggestions as the user is typing inside a token. Read the description of `trigger` for more.",
          "parameters": [
            {
              "name": "tokens",
              "description": "a tokenized array of what the user has typed"
            },
            {
              "name": "executeShellCommand",
              "description": "an async function that allows you to execute a shell command on the user's system and get the output as a string."
            },
            {
              "name": "shellContext",
              "description": "an object containing a user's currentWorkingDirectory, currentProcess, and if relevant, the sshPrefix string that can be used if the user is in an SSH session."
            }
          ],
          "optional": true,
          "declaration": "custom?: (\n  tokens: string[],\n  executeShellCommand: (\n    commandToExecute: string,\n    cwd?: string\n  ) => Promise<string>,\n  generatorContext: {\n    currentWorkingDirectory: string\n    currentProcess: string\n    sshPrefix: string\n  } & {\n    isDangerous?: boolean\n    searchTerm: string\n  }\n) => Promise<Suggestion[]>",
          "examples": [
            "In `cd` the custom function will combine the current working directory with everything up to the last `\"/\"` in the last token. It will then run `ls` at this path and generate a list of suggestions accordingly.\ne.g. if the user was currently in their home directory and typed \"cd desktop/abcdef\", then the custom function would return a list of directories at the `~/desktop` directory\nif the user was currently in their home directory and typed \"cd desktop/my_folder/second_folder/aaaaa\", then the custom function would return a list of directories at the `~/desktop/my_folder/second_folder` directory\nif the user was currently in their home directory and typed \"cd /usr/bin/\", then the custom function would return a list of directories at the `/usr/bin/` directory",
            "```ts\nconst generator: Fig.Generator = {\n  custom: async (tokens, executeShellCommand) => {\n    const out = await executeShellCommand(\"ls\");\n    return out.split(\"\\n\").map((elm) => ({ name: elm }));\n  },\n};\n```"
          ],
          "hasDocComment": true
        },
        {
          "name": "cache",
          "excluded": false,
          "summary": "Cache the response of generators for a specific period time and optionally by directory the commands were executed in.",
          "discussion": "For commands that take a long time to run, Fig gives you the option to cache their response. You can cache the response globally or just by the directory they were run in.\nWe currently have two cache strategies:\n- `max-age` (default): you just need to specify a `ttl` (time to live) for how long the cache will last (this is a number)\n- `stale-while-revalidate`: when cache becomes stale fig will return the stale data while fetching the updated one. This strategy also accepts a `ttl` to configure how long it takes for the cache to become stale.\nYou can also optionally turn on the ability to just cache by directory (`cacheByDirectory: true`)",
          "parameters": [],
          "optional": true,
          "declaration": "cache?: (\n  | {\n      strategy?: \"max-age\"\n      /**\n       * The time to live for the cache in milliseconds.\n       * @example\n       * 3600\n       */\n      ttl: number\n    }\n  | {\n      strategy: \"stale-while-revalidate\"\n      /**\n       * The time to live for the cache in milliseconds.\n       * @example\n       * 3600\n       */\n      ttl?: number\n    }\n) & {\n  /**\n   * Whether the cache should be based on the directory the user was currently in or not.\n   * @defaultValue false\n   */\n  cacheByDirectory?: boolean\n}",
          "examples": ["The kubernetes spec makes use of this."],
          "hasDocComment": true
        }
      ],
      "inheritedMembers": []
    }
  ],
  "typeAliases": [
    {
      "name": "TemplateStrings",
      "declaration": "type TemplateStrings = \"filepaths\" | \"folders\" | \"history\" | \"help\"",
      "summary": "Templates are generators prebuilt by Fig.",
      "discussion": "Here are the three templates:\n- filepaths: show folders and filepaths. Allow autoexecute on filepaths\n- folders: show folders only. Allow autoexecute on folders\n- history: show suggestions for all items in history matching this pattern\n- help: show subcommands. Only includes the 'siblings' of the nearest 'parent' subcommand",
      "examples": [],
      "parameters": []
    },
    {
      "name": "Template",
      "declaration": "type Template =\n  | (\"filepaths\" | \"folders\" | \"history\" | \"help\")\n  | (\"filepaths\" | \"folders\" | \"history\" | \"help\")[]",
      "summary": "A template which is a single TemplateString or an array of TemplateStrings",
      "discussion": "Templates are generators prebuilt by Fig. Here are the three templates:\n- filepaths: show folders and filepaths. Allow autoexecute on filepaths\n- folders: show folders only. Allow autoexecute on folders\n- history: show suggestions for all items in history matching this pattern\n- help: show subcommands. Only includes the 'siblings' of the nearest 'parent' subcommand",
      "examples": [
        "`cd` uses the \"folders\" template\n`ls` used  [\"filepaths\", \"folders\"]. Why both? Because if I `ls` a directory, we want to enable a user to autoexecute on this directory. If we just did \"filepaths\" they couldn't autoexecute."
      ],
      "parameters": []
    },
    {
      "name": "HistoryContext",
      "declaration": "type HistoryContext = {\n  currentWorkingDirectory: string\n  time: number\n  exitCode: number\n  shell: string\n}",
      "examples": [],
      "parameters": []
    },
    {
      "name": "TemplateSuggestionContext",
      "declaration": "type TemplateSuggestionContext =\n  | {\n      templateType: \"filepaths\"\n    }\n  | {\n      templateType: \"folders\"\n    }\n  | {\n      templateType: \"help\"\n    }\n  | ({\n      templateType: \"history\"\n    } & Partial<{\n      currentWorkingDirectory: string\n      time: number\n      exitCode: number\n      shell: string\n    }>)",
      "examples": [],
      "parameters": []
    },
    {
      "name": "TemplateSuggestion",
      "declaration": "type TemplateSuggestion = Modify<\n  Suggestion,\n  {\n    name?: string\n    context:\n      | {\n          templateType: \"filepaths\"\n        }\n      | {\n          templateType: \"folders\"\n        }\n      | {\n          templateType: \"help\"\n        }\n      | ({\n          templateType: \"history\"\n        } & Partial<{\n          currentWorkingDirectory: string\n          time: number\n          exitCode: number\n          shell: string\n        }>)\n  }\n>",
      "examples": [],
      "parameters": []
    },
    {
      "name": "SpecLocation",
      "declaration": "type SpecLocation =\n  | {\n      type: \"local\"\n      path?: string\n      name: string\n    }\n  | {\n      type: \"global\"\n      name: string\n    }",
      "summary": "The SpecLocation object defines well... the location of the completion spec we want to load.\nSpecs can be \"global\" (ie hosted by Fig's cloud) or \"local\" (ie stored on your local machine)",
      "discussion": "**The `SpecLocation` Object**\n\nThe SpecLocation object defines well... the location of the completion spec we want to load.\nSpecs can be \"global\" (ie hosted by Fig's cloud) or \"local\" (ie stored on your local machine).\n\n- Global `SpecLocation`:\nLoad specs hosted in Fig's Cloud. Assume the current working directory is here: https://github.com/withfig/autocomplete/tree/master/src. Now set the value for the \"name\" prop to the relative location of your spec (without the .js file extension)\n```js\n// e.g.\n{ type: \"global\", name: \"aws/s3\" } // Loads up the aws s3 completion spec\n{ type: \"global\", name: \"python/http.server\" } // Loads up the http.server completion spec\n```\n\n- Local `SpecLocation`:\nLoad specs saved on your local system / machine. Assume the current working directory is the user's current working directory.\nThe `name` prop should take the name of the spec (without the .js file extension) e.g. my_cli_tool\nThe `path` prop should take an absolute path OR a relative path (relative to the user's current working directory). The path should be to the directory that contains the `.fig` folder. Fig will then assume your spec is located in `.fig/autocomplete/build/`\n```js\n// e.g.\n{ type: \"global\", path: \"node_modules/cowsay\", name: \"cowsay_cli\" }  // will look for `cwd/node_modules/cowsay/.fig/autocomplete/build/cowsay_cli.js`\n{ type: \"global\", path: \"~\", name: \"my_cli\" }  // will look for `~/.fig/autocomplete/build/my_cli.js`\n```",
      "examples": [],
      "parameters": []
    },
    {
      "name": "LoadSpec",
      "declaration": "type LoadSpec =\n  | string\n  | Subcommand\n  | ((\n      token: string,\n      executeShellCommand: (\n        commandToExecute: string,\n        cwd?: string\n      ) => Promise<string>\n    ) => Promise<SpecLocation | SpecLocation[] | Subcommand>)",
      "summary": "Dynamically load up another completion spec at runtime.\n\nSee [`loadSpec` property in Subcommand Object](https://fig.io/docs/reference/subcommand#loadspec).",
      "examples": [],
      "parameters": []
    },
    {
      "name": "SuggestionType",
      "declaration": "type SuggestionType =\n  | \"folder\"\n  | \"file\"\n  | \"arg\"\n  | \"subcommand\"\n  | \"option\"\n  | \"special\"\n  | \"mixin\"\n  | \"shortcut\"",
      "summary": "The type of a suggestion object.",
      "discussion": "The type determines:\n- the default icon Fig uses (e.g. a file or folder searches for the system icon, a subcommand has a specific icon etc)\n- whether we allow users to auto-execute a command",
      "examples": [],
      "parameters": []
    },
    {
      "name": "SingleOrArray",
      "declaration": "type SingleOrArray<T> = T | T[]",
      "summary": "A single object of type `T` or an array of objects of type `T`.",
      "examples": [],
      "parameters": []
    },
    {
      "name": "GetVersionCommand",
      "declaration": "type GetVersionCommand = (\n  executeShellCommand: (\n    commandToExecute: string,\n    cwd?: string\n  ) => Promise<string>\n) => Promise<string>",
      "summary": "An async function that returns the version of a given CLI tool.",
      "returns": "The version of a CLI tool",
      "discussion": "This is used in completion specs that want to version themselves the same way CLI tools are versioned. See fig.io/docs",
      "examples": ["`1.0.22`", "`v26`"],
      "parameters": [
        {
          "name": "executeShellCommand",
          "description": "an async function that allows you to execute a shell command on the user's system and get the output as a string."
        }
      ]
    },
    {
      "name": "ShellContext",
      "declaration": "type ShellContext = {\n  currentWorkingDirectory: string\n  currentProcess: string\n  sshPrefix: string\n}",
      "summary": "Context about a current shell session.",
      "examples": [],
      "parameters": []
    },
    {
      "name": "GeneratorContext",
      "declaration": "type GeneratorContext = {\n  currentWorkingDirectory: string\n  currentProcess: string\n  sshPrefix: string\n} & {\n  isDangerous?: boolean\n  searchTerm: string\n}",
      "examples": [],
      "parameters": []
    },
    {
      "name": "Function",
      "declaration": "type Function<T = void, R = void> = (param: T) => R",
      "summary": "A function which can have a `T` argument and a `R` result.",
      "returns": "Something of type `R`",
      "examples": [],
      "parameters": [{ "name": "param", "description": "A param of type `R`" }]
    },
    {
      "name": "Modify",
      "declaration": "type Modify<T, R> = Omit<T, keyof R> & R",
      "summary": "A utility type to modify a property type",
      "examples": [],
      "parameters": []
    },
    {
      "name": "StringOrFunction",
      "declaration": "type StringOrFunction<T = void, R = void> = string | ((param: T) => R)",
      "summary": "A `string` OR a `function` which can have a `T` argument and a `R` result.",
      "returns": "Something of type `R`",
      "examples": [],
      "parameters": [{ "name": "param", "description": "A param of type `R`" }]
    },
    {
      "name": "ArgDiff",
      "declaration": "type ArgDiff = Modify<\n  Fig.Arg,\n  {\n    remove?: true\n  }\n>",
      "summary": "",
      "examples": [],
      "parameters": []
    },
    {
      "name": "OptionDiff",
      "declaration": "type OptionDiff = Modify<\n  Fig.Option,\n  {\n    args?: ArgDiff | ArgDiff[]\n    remove?: true\n  }\n>",
      "summary": "",
      "examples": [],
      "parameters": []
    },
    {
      "name": "SubcommandDiff",
      "declaration": "type SubcommandDiff = Modify<\n  Fig.Subcommand,\n  {\n    subcommands?: SubcommandDiff[]\n    options?: OptionDiff[]\n    args?: ArgDiff | ArgDiff[]\n    remove?: true\n  }\n>",
      "summary": "",
      "examples": [],
      "parameters": []
    },
    {
      "name": "SpecDiff",
      "declaration": "type SpecDiff = Omit<SubcommandDiff, \"name\" | \"remove\">",
      "summary": "",
      "examples": [],
      "parameters": []
    },
    {
      "name": "VersionDiffMap",
      "declaration": "type VersionDiffMap = Record<string, SpecDiff>",
      "summary": "",
      "examples": [],
      "parameters": []
    },
    {
      "name": "Spec",
      "declaration": "type Spec =\n  | Subcommand\n  | ((version?: string) => Subcommand)\n  | ((version?: string) => {\n      versionedSpecPath: string\n      version?: string\n    })",
      "summary": "A spec object.\nCan be one of\n1. A subcommand\n2. A function that dynamically computes a subcommand\n3. A function that returns the path to a versioned spec files (that exports a base subcommand and { versions: VersionDiffMap }",
      "examples": [],
      "parameters": []
    },
    {
      "name": "ExecuteShellCommandFunction",
      "declaration": "type ExecuteShellCommandFunction = (\n  commandToExecute: string,\n  cwd?: string\n) => Promise<string>",
      "summary": "An async function to execute a shell command",
      "returns": "The output of the shell command as a string",
      "discussion": "The `cwd` parameter will add a `cd [cwd] &&` before the command itself.",
      "examples": [
        "`ExecuteShellCommandFunction(\"echo hello world\")` will return `hello world`"
      ],
      "parameters": [
        {
          "name": "commandToExecute",
          "description": "The shell command you want to execute"
        },
        {
          "name": "cwd",
          "description": "The directory in which to execute the command"
        }
      ]
    },
    {
      "name": "CacheMaxAge",
      "declaration": "type CacheMaxAge = {\n  strategy?: \"max-age\"\n  /**\n   * The time to live for the cache in milliseconds.\n   * @example\n   * 3600\n   */\n  ttl: number\n}",
      "examples": [],
      "parameters": []
    },
    {
      "name": "CacheStaleWhileRevalidate",
      "declaration": "type CacheStaleWhileRevalidate = {\n  strategy: \"stale-while-revalidate\"\n  /**\n   * The time to live for the cache in milliseconds.\n   * @example\n   * 3600\n   */\n  ttl?: number\n}",
      "examples": [],
      "parameters": []
    },
    {
      "name": "Cache",
      "declaration": "type Cache = (\n  | {\n      strategy?: \"max-age\"\n      /**\n       * The time to live for the cache in milliseconds.\n       * @example\n       * 3600\n       */\n      ttl: number\n    }\n  | {\n      strategy: \"stale-while-revalidate\"\n      /**\n       * The time to live for the cache in milliseconds.\n       * @example\n       * 3600\n       */\n      ttl?: number\n    }\n) & {\n  /**\n   * Whether the cache should be based on the directory the user was currently in or not.\n   * @defaultValue false\n   */\n  cacheByDirectory?: boolean\n}",
      "examples": [],
      "parameters": []
    },
    {
      "name": "TriggerOnChange",
      "declaration": "type TriggerOnChange = {\n  /** Trigger on any change to the token */\n  on: \"change\"\n}",
      "examples": [],
      "parameters": []
    },
    {
      "name": "TriggerOnThreshold",
      "declaration": "type TriggerOnThreshold = {\n  /** Trigger when the length of the token changes past a threshold */\n  on: \"threshold\"\n  length: number\n}",
      "examples": [],
      "parameters": []
    },
    {
      "name": "TriggerOnMatch",
      "declaration": "type TriggerOnMatch = {\n  /** Trigger when the index of a string changes */\n  on: \"match\"\n  string: string | string[]\n}",
      "examples": [],
      "parameters": []
    },
    {
      "name": "Trigger",
      "declaration": "type Trigger =\n  | string\n  | ((newToken: string, oldToken: string) => boolean)\n  | {\n      /** Trigger on any change to the token */\n      on: \"change\"\n    }\n  | {\n      /** Trigger when the length of the token changes past a threshold */\n      on: \"threshold\"\n      length: number\n    }\n  | {\n      /** Trigger when the index of a string changes */\n      on: \"match\"\n      string: string | string[]\n    }",
      "examples": [],
      "parameters": []
    }
  ]
}
